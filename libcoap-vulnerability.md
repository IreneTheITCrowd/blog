## CVE-2025-50518
A use-after-free vulnerability exists in the coap_delete_pdu_lkd function within coap_pdu.c of the libcoap library. This issue occurs due to improper handling of memory after the freeing of a PDU object, leading to potential memory corruption or the possibility of executing arbitrary code.

 
[Additional Information]
 This vulnerability was identified during fuzz testing using libFuzzer on libcoap. The issue results from mishandling of memory in the coap_pdu object management functions.
 
 =14403==ERROR: AddressSanitizer: heap-use-after-free on address 0x60d000000058 at pc 0x00000059f74d bp 0x7ffd252485f0 sp 0x7ffd252485e8
 READ of size 4 at 0x60d000000058 thread T0
     #0 0x59f74c in coap_delete_pdu_lkd /home/irene/libcoap/src/coap_pdu.c:192:14
     #1 0x59f65d in coap_delete_pdu /home/irene/libcoap/src/coap_pdu.c:185:3
     #2 0x55511e in LLVMFuzzerTestOneInput /home/irene/libcoap/build/fuzz.cpp
     #3 0x45d321 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/home/irene/libcoap/build/test_fuzz+0x45d321)
     #4 0x45f05a in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) (/home/irene/libcoap/build/test_fuzz+0x45f05a)
     #5 0x45f6e9 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) (/home/irene/libcoap/build/test_fuzz+0x45f6e9)
     #6 0x44e3be in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/home/irene/libcoap/build/test_fuzz+0x44e3be)
     #7 0x477202 in main (/home/irene/libcoap/build/test_fuzz+0x477202)
     #8 0x7f26a4c8f082 in __libc_start_main /build/glibc-FcRMwW/glibc-2.31/csu/../csu/libc-start.c:308:16

 Code:
 coap_pdu.c:
 
 void  coap_delete_pdu_lkd(coap_pdu_t *pdu) {
   
   if (pdu != NULL) {
   
     if (pdu->ref) {
     
       pdu->ref--;
       
       return;
       
     }
     
 #ifdef WITH_LWIP
 
     pbuf_free(pdu->pbuf);
     
 #else
 
     if (pdu->token != NULL)
     
       coap_free_type(COAP_PDU_BUF, pdu->token - pdu->max_hdr_size);
       
 #endif
 
     coap_delete_binary(pdu->data_free);
     
    coap_free_type(COAP_PDU, pdu);
    
  }
  
 }

### 1. What the code does
This is a **reference counting** cleanup function:

If the pointer is non-NULL, it checks the reference counter (pdu->ref)

If ref > 0, it decrements and returns

If ref == 0, the remaining code will free the pdu object

### 2.Why UAF can still occur
 if (pdu != NULL) only checks whether the pointer is NULL — it does not tell you whether the memory it points to is still valid.

**UAF scenario:**

1.Multiple parts of the program hold the same pdu pointer.

2.One holder calls coap_delete_pdu_lkd() when ref becomes 0 → the function frees the pdu memory.

3.Another holder still has the same pointer value (non-NULL), but the memory has already been freed.

4.That second holder calls coap_delete_pdu_lkd(pdu).

if (pdu != NULL) passes because the pointer value is non-zero.

Accessing pdu->ref now reads from freed memory → Use-After-Free.

### 3. Key point
A pointer to freed memory is called a dangling pointer.

It’s not NULL.

The memory may have been reused by another allocation.

Any read or write through it is undefined behavior, which is exactly what a UAF is.<br/>
<br/>



**[VulnerabilityType Other]**
 heap-use-after-free


**[Vendor of Product]**
libcoap


**[Affected Product Code Base]**
 libcoap - 4.3.5


 **[Affected Component]**
 coap_pdu.c, coap_delete_pdu_lkd, coap_delete_pdu, coap_send_lkd, coap_send


 **[Attack Type]**
 Local


 **[Impact Code execution]**
 true


 **[Impact Information Disclosure]**
 true


**[Attack Vectors]**
 The vulnerability can be exploited by passing specially crafted input to the fuzzing function, causing a use-after-free (UAF) condition during the deletion of a PDU (Protocol Data Unit) object.


 **[Reference]**
 https://github.com/obgm/libcoap.git


**[Discoverer]**
Discovered by Xu Yaoyao, security researcher.
